// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/fwojciec/gqlmeetup"
	"sync"
)

var (
	lockTokenServiceMockCheckAccessToken   sync.RWMutex
	lockTokenServiceMockCheckRefreshToken  sync.RWMutex
	lockTokenServiceMockDecodeRefreshToken sync.RWMutex
	lockTokenServiceMockIssue              sync.RWMutex
	lockTokenServiceMockRetrieve           sync.RWMutex
	lockTokenServiceMockStore              sync.RWMutex
)

// Ensure, that TokenServiceMock does implement gqlmeetup.TokenService.
// If this is not the case, regenerate this file with moq.
var _ gqlmeetup.TokenService = &TokenServiceMock{}

// TokenServiceMock is a mock implementation of gqlmeetup.TokenService.
//
//     func TestSomethingThatUsesTokenService(t *testing.T) {
//
//         // make and configure a mocked gqlmeetup.TokenService
//         mockedTokenService := &TokenServiceMock{
//             CheckAccessTokenFunc: func(token string) (*gqlmeetup.AccessTokenPayload, error) {
// 	               panic("mock out the CheckAccessToken method")
//             },
//             CheckRefreshTokenFunc: func(token string, pwdHash string) (*gqlmeetup.RefreshTokenPayload, error) {
// 	               panic("mock out the CheckRefreshToken method")
//             },
//             DecodeRefreshTokenFunc: func(token string) (string, error) {
// 	               panic("mock out the DecodeRefreshToken method")
//             },
//             IssueFunc: func(userEmail string, isAdmin bool, pwdHash string) (*gqlmeetup.Tokens, error) {
// 	               panic("mock out the Issue method")
//             },
//             RetrieveFunc: func(ctx context.Context) (*gqlmeetup.AccessTokenPayload, error) {
// 	               panic("mock out the Retrieve method")
//             },
//             StoreFunc: func(in1 context.Context, in2 *gqlmeetup.AccessTokenPayload) context.Context {
// 	               panic("mock out the Store method")
//             },
//         }
//
//         // use mockedTokenService in code that requires gqlmeetup.TokenService
//         // and then make assertions.
//
//     }
type TokenServiceMock struct {
	// CheckAccessTokenFunc mocks the CheckAccessToken method.
	CheckAccessTokenFunc func(token string) (*gqlmeetup.AccessTokenPayload, error)

	// CheckRefreshTokenFunc mocks the CheckRefreshToken method.
	CheckRefreshTokenFunc func(token string, pwdHash string) (*gqlmeetup.RefreshTokenPayload, error)

	// DecodeRefreshTokenFunc mocks the DecodeRefreshToken method.
	DecodeRefreshTokenFunc func(token string) (string, error)

	// IssueFunc mocks the Issue method.
	IssueFunc func(userEmail string, isAdmin bool, pwdHash string) (*gqlmeetup.Tokens, error)

	// RetrieveFunc mocks the Retrieve method.
	RetrieveFunc func(ctx context.Context) (*gqlmeetup.AccessTokenPayload, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(in1 context.Context, in2 *gqlmeetup.AccessTokenPayload) context.Context

	// calls tracks calls to the methods.
	calls struct {
		// CheckAccessToken holds details about calls to the CheckAccessToken method.
		CheckAccessToken []struct {
			// Token is the token argument value.
			Token string
		}
		// CheckRefreshToken holds details about calls to the CheckRefreshToken method.
		CheckRefreshToken []struct {
			// Token is the token argument value.
			Token string
			// PwdHash is the pwdHash argument value.
			PwdHash string
		}
		// DecodeRefreshToken holds details about calls to the DecodeRefreshToken method.
		DecodeRefreshToken []struct {
			// Token is the token argument value.
			Token string
		}
		// Issue holds details about calls to the Issue method.
		Issue []struct {
			// UserEmail is the userEmail argument value.
			UserEmail string
			// IsAdmin is the isAdmin argument value.
			IsAdmin bool
			// PwdHash is the pwdHash argument value.
			PwdHash string
		}
		// Retrieve holds details about calls to the Retrieve method.
		Retrieve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *gqlmeetup.AccessTokenPayload
		}
	}
}

// CheckAccessToken calls CheckAccessTokenFunc.
func (mock *TokenServiceMock) CheckAccessToken(token string) (*gqlmeetup.AccessTokenPayload, error) {
	if mock.CheckAccessTokenFunc == nil {
		panic("TokenServiceMock.CheckAccessTokenFunc: method is nil but TokenService.CheckAccessToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	lockTokenServiceMockCheckAccessToken.Lock()
	mock.calls.CheckAccessToken = append(mock.calls.CheckAccessToken, callInfo)
	lockTokenServiceMockCheckAccessToken.Unlock()
	return mock.CheckAccessTokenFunc(token)
}

// CheckAccessTokenCalls gets all the calls that were made to CheckAccessToken.
// Check the length with:
//     len(mockedTokenService.CheckAccessTokenCalls())
func (mock *TokenServiceMock) CheckAccessTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	lockTokenServiceMockCheckAccessToken.RLock()
	calls = mock.calls.CheckAccessToken
	lockTokenServiceMockCheckAccessToken.RUnlock()
	return calls
}

// CheckRefreshToken calls CheckRefreshTokenFunc.
func (mock *TokenServiceMock) CheckRefreshToken(token string, pwdHash string) (*gqlmeetup.RefreshTokenPayload, error) {
	if mock.CheckRefreshTokenFunc == nil {
		panic("TokenServiceMock.CheckRefreshTokenFunc: method is nil but TokenService.CheckRefreshToken was just called")
	}
	callInfo := struct {
		Token   string
		PwdHash string
	}{
		Token:   token,
		PwdHash: pwdHash,
	}
	lockTokenServiceMockCheckRefreshToken.Lock()
	mock.calls.CheckRefreshToken = append(mock.calls.CheckRefreshToken, callInfo)
	lockTokenServiceMockCheckRefreshToken.Unlock()
	return mock.CheckRefreshTokenFunc(token, pwdHash)
}

// CheckRefreshTokenCalls gets all the calls that were made to CheckRefreshToken.
// Check the length with:
//     len(mockedTokenService.CheckRefreshTokenCalls())
func (mock *TokenServiceMock) CheckRefreshTokenCalls() []struct {
	Token   string
	PwdHash string
} {
	var calls []struct {
		Token   string
		PwdHash string
	}
	lockTokenServiceMockCheckRefreshToken.RLock()
	calls = mock.calls.CheckRefreshToken
	lockTokenServiceMockCheckRefreshToken.RUnlock()
	return calls
}

// DecodeRefreshToken calls DecodeRefreshTokenFunc.
func (mock *TokenServiceMock) DecodeRefreshToken(token string) (string, error) {
	if mock.DecodeRefreshTokenFunc == nil {
		panic("TokenServiceMock.DecodeRefreshTokenFunc: method is nil but TokenService.DecodeRefreshToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	lockTokenServiceMockDecodeRefreshToken.Lock()
	mock.calls.DecodeRefreshToken = append(mock.calls.DecodeRefreshToken, callInfo)
	lockTokenServiceMockDecodeRefreshToken.Unlock()
	return mock.DecodeRefreshTokenFunc(token)
}

// DecodeRefreshTokenCalls gets all the calls that were made to DecodeRefreshToken.
// Check the length with:
//     len(mockedTokenService.DecodeRefreshTokenCalls())
func (mock *TokenServiceMock) DecodeRefreshTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	lockTokenServiceMockDecodeRefreshToken.RLock()
	calls = mock.calls.DecodeRefreshToken
	lockTokenServiceMockDecodeRefreshToken.RUnlock()
	return calls
}

// Issue calls IssueFunc.
func (mock *TokenServiceMock) Issue(userEmail string, isAdmin bool, pwdHash string) (*gqlmeetup.Tokens, error) {
	if mock.IssueFunc == nil {
		panic("TokenServiceMock.IssueFunc: method is nil but TokenService.Issue was just called")
	}
	callInfo := struct {
		UserEmail string
		IsAdmin   bool
		PwdHash   string
	}{
		UserEmail: userEmail,
		IsAdmin:   isAdmin,
		PwdHash:   pwdHash,
	}
	lockTokenServiceMockIssue.Lock()
	mock.calls.Issue = append(mock.calls.Issue, callInfo)
	lockTokenServiceMockIssue.Unlock()
	return mock.IssueFunc(userEmail, isAdmin, pwdHash)
}

// IssueCalls gets all the calls that were made to Issue.
// Check the length with:
//     len(mockedTokenService.IssueCalls())
func (mock *TokenServiceMock) IssueCalls() []struct {
	UserEmail string
	IsAdmin   bool
	PwdHash   string
} {
	var calls []struct {
		UserEmail string
		IsAdmin   bool
		PwdHash   string
	}
	lockTokenServiceMockIssue.RLock()
	calls = mock.calls.Issue
	lockTokenServiceMockIssue.RUnlock()
	return calls
}

// Retrieve calls RetrieveFunc.
func (mock *TokenServiceMock) Retrieve(ctx context.Context) (*gqlmeetup.AccessTokenPayload, error) {
	if mock.RetrieveFunc == nil {
		panic("TokenServiceMock.RetrieveFunc: method is nil but TokenService.Retrieve was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	lockTokenServiceMockRetrieve.Lock()
	mock.calls.Retrieve = append(mock.calls.Retrieve, callInfo)
	lockTokenServiceMockRetrieve.Unlock()
	return mock.RetrieveFunc(ctx)
}

// RetrieveCalls gets all the calls that were made to Retrieve.
// Check the length with:
//     len(mockedTokenService.RetrieveCalls())
func (mock *TokenServiceMock) RetrieveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	lockTokenServiceMockRetrieve.RLock()
	calls = mock.calls.Retrieve
	lockTokenServiceMockRetrieve.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *TokenServiceMock) Store(in1 context.Context, in2 *gqlmeetup.AccessTokenPayload) context.Context {
	if mock.StoreFunc == nil {
		panic("TokenServiceMock.StoreFunc: method is nil but TokenService.Store was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *gqlmeetup.AccessTokenPayload
	}{
		In1: in1,
		In2: in2,
	}
	lockTokenServiceMockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	lockTokenServiceMockStore.Unlock()
	return mock.StoreFunc(in1, in2)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedTokenService.StoreCalls())
func (mock *TokenServiceMock) StoreCalls() []struct {
	In1 context.Context
	In2 *gqlmeetup.AccessTokenPayload
} {
	var calls []struct {
		In1 context.Context
		In2 *gqlmeetup.AccessTokenPayload
	}
	lockTokenServiceMockStore.RLock()
	calls = mock.calls.Store
	lockTokenServiceMockStore.RUnlock()
	return calls
}
